<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Config

//Behavior
ignore = array_create(0);
ignore[0] = object_index;
ignore[1] = objWorld;
ignore[2] = objTriggerManager;
ignore[3] = objPlayer;
ignore[4] = objBow;


//Keybinds
bindPlaytest = vk_enter;
bindRestart = ord('R');


//Visual
wview = 800;
hview = 608;

defaultSprite = sprMintDefault;
viewLerp = 0.25;
font = fMint;


//Colors
colorFillDark = make_color_rgb(47, 63, 59);
colorFillLight = make_color_rgb(114, 153, 143);

colorButton = make_color_rgb(184, 216, 208);
colorButtonHover = make_color_rgb(220, 247, 240);
colorButtonOff = make_color_rgb(86, 114, 107);

colorTextbox = make_color_rgb(220, 247, 240);
colorTextboxHover = make_color_rgb(242, 252, 249);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Room variables

//Room
instances = array_create(0);
tiles = array_create(0);
backgrounds = array_create(0);
for (var b = 0; b &lt; 8; b++)
{
    backgrounds[b] = ds_map_create();
}
backgroundColor = noone;

roomWidth = -1;
roomHeight = -1;
roomSpeed = -1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Layout
tlm = 108; //Top left height
lm = 192; //Left margin
tm = 32; //Top margin
rm = 192; //Right margin
bm = 32; //Bottom margin
sw = wview+lm+rm;
sh = hview+tm+bm;


//Window positions
windowPlaytestX = 0;
windowPlaytestY = 0;
windowPlaytestWidth = 0;
windowPlaytestHeight = 0;
windowEditorX = window_get_x();
windowEditorY = window_get_y();
windowEditorWidth = wview + lm + rm;
windowEditorHeight = hview + tm + bm;


//Editor
state = "init";
mode = "instances";
editorRoom = room_add();
playtestRoom = room_add();

selectedInstances = ds_list_create();
hoveredInstance = noone;
instancePreviewX = 0;
instancePreviewY = 0;

viewTargetX = 0;
viewTargetY = 0;
viewX = viewTargetX;
viewY = viewTargetY;
targetZoom = 1;
zoom = targetZoom;

mouseState = "none";
clickStartX = 0;
clickStartY = 0;
snapX = 32;
snapY = 32;
tooltip = "";

selectionLeft = 0;
selectionTop = 0;
selectionRight = 0;
selectionBottom = 0;

objectPalette = ds_list_create();
paletteButtons = array_create(0);
selectedObject = objBlock;

mint_get_scale_handles();
scaleState = 0

showGrid = true;
showObjects = true;
showInvisibleObjects = true;
showTiles = true;
showBackgrounds = true;
showForegrounds = true;

mint_mouse_update(true);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///GUI
hoveredButton = noone;
buttons = array_create(0);

hoveredTextbox = noone;
selectedTextbox = noone;
textboxes = array_create(0);
textboxTimer = 0;

//Top left
//mint_add_button(6, 6, "tl", 88, 30, 6, sprMintIcon, 0, "Save", nop);
//mint_add_button(98, 6, "tl", 88, 30, 6, sprMintIcon, 1, "Room settings", nop);
//mint_add_button(6, 40, "tl", 88, 30, 6, sprMintIcon, 2, "Instances", nop);
//mint_add_button(98, 40, "tl", 88, 30, 6, sprMintIcon, 3, "Tiles", nop);
//mint_add_button(6, 74, "tl", 88, 30, 6, sprMintIcon, 4, "Backgrounds", nop);
//mint_add_button(98, 74, "tl", 88, 30, 6, sprMintIcon, 5, "Views", nop);

//Top
//mint_add_button(2, 4, "t", 24, 24, 4, sprMintIconMini, 0, "Undo", nop);
mint_add_button(46, 4, "t", 24, 24, 4, sprMintIconMini, 1, "Show grid", mint_callback_switch, "showGrid");
mint_add_textbox(74, 4, "t", 32, 24, 4, snapX, true, "", mint_callback_update_snap, mint_callback_finish_snap, true, true);
mint_add_textbox(110, 4, "t", 32, 24, 4, snapY, true, "", mint_callback_update_snap, mint_callback_finish_snap, false, false);
mint_add_button(162, 4, "t", 24, 24, 4, sprMintIconMini, 2, "Show instances", mint_callback_switch, "showObjects");
mint_add_button(190, 4, "t", 24, 24, 4, sprMintIconMini, 3, "Show instances of invisible objects", mint_callback_switch, "showInvisibleObjects");
mint_add_button(218, 4, "t", 24, 24, 4, sprMintIconMini, 4, "Show tiles", mint_callback_switch, "showTiles");
mint_add_button(246, 4, "t", 24, 24, 4, sprMintIconMini, 5, "Show backgrounds", mint_callback_switch, "showBackgrounds");
mint_add_button(274, 4, "t", 24, 24, 4, sprMintIconMini, 6, "Show foregrounds", mint_callback_switch, "showForegrounds");
//var v = mint_add_button(302, 4, "t", 24, 24, 4, sprMintIconMini, 7, "Show views", nop);
//v[? "on"] = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Start

room_goto(room);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state == "editor"</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Start playtest

if (keyboard_check_pressed(bindPlaytest) &amp;&amp; selectedTextbox == noone)
{
    mint_regenerate_arrays();
    mint_get_window_position(false);
    ds_list_clear(selectedInstances);
    draw_clear(c_black);
    
    room_instance_clear(playtestRoom);
    room_tile_clear(playtestRoom);
    room_set_width(playtestRoom, roomWidth);
    room_set_height(playtestRoom, roomHeight);
    room_set_view_enabled(playtestRoom, true);
    room_set_view(playtestRoom, 0, true, 0, 0, 800, 608, 0, 0, 800, 608, 0, 0, 0, 0, -1);
    state = "start playtest";
    room_goto(playtestRoom);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Resize window, find hovered instance

var w = window_get_width(), h = window_get_height();
if ((w != sh || h != sw) &amp;&amp; (w &gt; 0) &amp;&amp; (h &gt; 0))
{
    mint_resize_window(true);
    sw = w;
    sh = h;
}

mint_mouse_update();

hoveredInstance = noone;
tooltip = "";
if (mint_mouse_in_room_view())
{
    with(objMintInstance)
    {
        if (visible &amp;&amp; mint_in_range(mouse_room_x, bbox_left, bbox_right) &amp;&amp; mint_in_range(mouse_room_y, bbox_top, bbox_bottom))
        {
            other.hoveredInstance = id;
            break;
        }
    }
    //hoveredInstance = instance_position(mouse_room_x, mouse_room_y, objMintInstance);
}
tooltip = mint_get_instance_tooltip(hoveredInstance);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Controls

hoveredButton = noone;
hoveredTextbox = noone;

if (mouse_check_button_pressed(mb_left))
{
    selectedTextbox = noone;
}

if (mode == "instances")
{
    instancePreviewX = snapX * floor(mouse_room_x / snapX);
    instancePreviewY = snapY * floor(mouse_room_y / snapY);

    if (mint_mouse_in_room_view())
    {
        switch(mouseState)
        {
            case "none":
                if (mouse_check_button_pressed(mb_left))
                {
                    clickStartX = mouse_room_x;
                    clickStartY = mouse_room_y;
                    scaleState = mint_check_for_scale_handle(mouse_room_x, mouse_room_y);
                    
                    if (scaleState != noone)
                    {
                        //Clicking a scale handle
                        mouseState = "scale";
                    }
                    else 
                    {
                        if (keyboard_check(vk_shift))
                        {
                            if (!keyboard_check(vk_control))
                            {
                                ds_list_clear(selectedInstances);
                                mint_update_selection_boundary();
                            }
                        
                            mouseState = "selection";
                        }
                        else if (hoveredInstance == noone)
                        {
                            //Clicking empty space
                            if (!keyboard_check(vk_control))
                            {
                                ds_list_clear(selectedInstances);
                                mint_update_selection_boundary();
                            }
                            
                            mouseState = "placing";
                        }
                        else if (ds_list_find_index(selectedInstances, hoveredInstance) &gt; -1)
                        {
                            //Clicking selected instance
                            if (keyboard_check(vk_control))
                            {
                                var index = ds_list_find_index(selectedInstances, hoveredInstance);
                                if (index == -1)
                                {
                                    ds_list_add(selectedInstances, hoveredInstance);
                                }
                                else
                                {
                                    ds_list_delete(selectedInstances, index);
                                }
                                mint_update_selection_boundary();
                            }
                            
                            mouseState = "wait";
                        }
                        else
                        {
                            //Clicking unselected instance
                            if (!keyboard_check(vk_control))
                            {
                                ds_list_clear(selectedInstances);
                            }
                            
                            ds_list_add(selectedInstances, hoveredInstance);
                            mint_update_selection_boundary();
                            
                            mouseState = "wait";
                        }
                    }
                }
                break;
            case "wait":
                if ((mouse_room_x != clickStartX || mouse_room_y != clickStartY))
                {
                    mouseState = "drag";
                }
                else if (mouse_check_button_released(mb_left))
                {
                    if (!keyboard_check(vk_control))
                    {
                        ds_list_clear(selectedInstances);
                        
                        if (hoveredInstance != noone)
                        {
                            ds_list_add(selectedInstances, hoveredInstance);
                        }
                        mint_update_selection_boundary();
                    }
                
                    mouseState = "none";
                }
                break;
            case "drag":
                var distX = snapX * floor((mouse_room_x - clickStartX) / snapX + 0.5);
                var distY = snapY * floor((mouse_room_y - clickStartY) / snapY + 0.5);
                clickStartX += distX;
                clickStartY += distY;
                for (var i = 0; i &lt; ds_list_size(selectedInstances); i++)
                {
                    selectedInstances[| i].x += distX;
                    selectedInstances[| i].y += distY;
                }
                mint_update_selection_boundary();
                break;
            case "selection":
                if (mouse_check_button_released(mb_left))
                {
                    var selL = min(clickStartX, mouse_room_x);
                    var selT = min(clickStartY, mouse_room_y);
                    var selR = max(clickStartX, mouse_room_x);
                    var selB = max(clickStartY, mouse_room_y);
                    with(objMintInstance)
                    {
                        if (visible &amp;&amp; selL &lt;= bbox_right &amp;&amp; selT &lt;= bbox_bottom &amp;&amp; selR &gt;= bbox_left &amp;&amp; selB &gt;= bbox_top)
                        {
                            var index = ds_list_find_index(other.selectedInstances, id);
                            if (index == -1)
                            {
                                ds_list_add(other.selectedInstances, id);
                            }
                        }
                    }
                    mint_update_selection_boundary();
                    mouseState = "none";
                }
                break;
            case "scale":
                var distX = snapX * floor((mouse_room_x - clickStartX) / snapX + 0.5);
                var distY = snapY * floor((mouse_room_y - clickStartY) / snapY + 0.5);
                var xZero = (scaleState[0] != 0) &amp;&amp; (selectionRight - selectionLeft + 1 == -scaleState[0] * distX);
                var yZero = (scaleState[1] != 0) &amp;&amp; (selectionBottom - selectionTop + 1 == -scaleState[1] * distY);
                var xFlip = (scaleState[0] != 0) &amp;&amp; (selectionRight - selectionLeft + 1 &lt; -scaleState[0] * distX);
                var yFlip = (scaleState[1] != 0) &amp;&amp; (selectionBottom - selectionTop + 1 &lt; -scaleState[1] * distY);
                if ((distX != 0 || distY != 0) &amp;&amp; !xZero &amp;&amp; !yZero)
                {
                    var oldL = selectionLeft, oldT = selectionTop, oldR = selectionRight, oldB = selectionBottom;
                    if (scaleState[0] != 0)
                    {
                        clickStartX += distX;
                        if (scaleState[0] == -1) selectionLeft += distX;
                        if (scaleState[0] == 1)  selectionRight += distX;
                    }
                    if (scaleState[1] != 0)
                    {
                        clickStartY += distY;
                        if (scaleState[1] == -1) selectionTop += distY;
                        if (scaleState[1] == 1)  selectionBottom += distY;
                    }
                    
                    for (var i = 0; i &lt; ds_list_size(selectedInstances); i++)
                    {
                        var inst = selectedInstances[| i];
                        if (scaleState[0] != 0)
                        {
                            var fX = (inst.x - oldL) / (oldR + 1 - oldL);
                            inst.x = lerp(selectionLeft, selectionRight + 1, fX);
                            inst.image_xscale *= (selectionRight - selectionLeft + 1) / (oldR - oldL + 1);
                        }
                        if (scaleState[1] != 0)
                        {
                            var fY = (inst.y - oldT) / (oldB + 1 - oldT);
                            inst.y = lerp(selectionTop, selectionBottom + 1, fY);
                            inst.image_yscale *= (selectionBottom - selectionTop + 1) / (oldB - oldT + 1);
                        }
                    } 
                    if (xFlip) scaleState[0] *= -1;
                    if (yFlip) scaleState[1] *= -1;
                    mint_update_selection_boundary();
                }
                break;
            case "placing":
                if (hoveredInstance == noone)
                {
                    with(instance_create(instancePreviewX, instancePreviewY, objMintInstance))
                    {
                        object = other.selectedObject;
                        var sprite = object_get_sprite(object);
                        if (sprite == -1)
                        {
                            sprite = other.defaultSprite;
                        }
                        sprite_index = sprite;
                        
                        ds_list_add(other.selectedInstances, id);
                    }
                    mint_update_selection_boundary();
                }
                break;
        }
        
        if (mouse_check_button(mb_right))
        {
            if (hoveredInstance != noone)
            {
                instance_destroy(hoveredInstance);
                hoveredInstance = noone;
            }
            ds_list_clear(selectedInstances);
            mint_update_selection_boundary();
        }
    }
    else
    {
        for(var i = 0; i &lt; array_length_1d(buttons); i++)
        {
            var _button = buttons[i];
            var _ox = mint_get_button_offset(_button[? "anchor"], true);
            var _oy = mint_get_button_offset(_button[? "anchor"], false);
            
            if (_button[? "visible"] &amp;&amp; (mint_in_range(mouse_window_x - _ox, _button[? "x"], _button[? "x"] + _button[? "width"] - 1)) &amp;&amp; (mint_in_range(mouse_window_y - _oy, _button[? "y"], _button[? "y"] + _button[? "height"] - 1)))
            {
                hoveredButton = _button;
                tooltip = hoveredButton[? "tooltip"];
            }
        }
        if (hoveredButton != noone &amp;&amp; mouse_check_button_pressed(mb_left))
        {
            script_execute(hoveredButton[? "callback"], hoveredButton, hoveredButton[? "callback arg"]);
        }
        if (hoveredButton == noone)
        {
            for(var i = 0; i &lt; array_length_1d(textboxes); i++)
            {
                var _textbox = textboxes[i];
                var _ox = mint_get_button_offset(_textbox[? "anchor"], true);
                var _oy = mint_get_button_offset(_textbox[? "anchor"], false);
                
                if (_textbox[? "visible"] &amp;&amp; (mint_in_range(mouse_window_x - _ox, _textbox[? "x"], _textbox[? "x"] + _textbox[? "width"] - 1)) &amp;&amp; (mint_in_range(mouse_window_y - _oy, _textbox[? "y"], _textbox[? "y"] + _textbox[? "height"] - 1)))
                {
                    hoveredTextbox = _textbox;
                    tooltip = _textbox[? "tooltip"];
                }
            }
            if (hoveredTextbox != noone)
            {
                if (mouse_check_button_pressed(mb_left) || mouse_check_button_pressed(mb_right))
                {
                    selectedTextbox = hoveredTextbox;
                    textboxTimer = 0;
                    keyboard_lastkey = -1;
                    keyboard_lastchar = "";
                    if (mouse_check_button_pressed(mb_right))
                    {
                        selectedTextbox[? "value"] = "";
                        selectedTextbox[? "display text"] = "";
                        selectedTextbox[? "tooltip"] = "";
                    }
                }
            }
        }
    }
        
    //Fallback to make sure mouse state doesn't get stuck
    if (!mouse_check_button(mb_left))
    {
        mouseState = "none";
    }
}

if (ds_list_empty(selectedInstances))
{
    viewTargetX += (keyboard_check(vk_right) - keyboard_check(vk_left)) * 8;
    viewTargetY += (keyboard_check(vk_down) - keyboard_check(vk_up)) * 8;
}
else
{
    var _nudgeX = keyboard_check_pressed(vk_right) - keyboard_check_pressed(vk_left);
    var _nudgeY = keyboard_check_pressed(vk_down) - keyboard_check_pressed(vk_up);
    if (_nudgeX != 0 || _nudgeY != 0)
    {
        for (var i = 0; i &lt; ds_list_size(selectedInstances); i++)
        {
            var inst = selectedInstances[| i];
            inst.x += _nudgeX;
            inst.y += _nudgeY;
            mint_update_selection_boundary();
        }
    }
}

if (mint_mouse_in_room_view())
{
    if (mouse_check_button(mb_middle))
    {
        viewTargetX -= (mouse_window_x - mouse_window_x_prev) / zoom;
        viewTargetY -= (mouse_window_y - mouse_window_y_prev) / zoom;
    }
    
    var s = mouse_wheel_up() - mouse_wheel_down();
    if (s != 0)
    {
        var zoomFactor = power(power(2, 1/4), s);
        targetZoom *= zoomFactor;
    }
}

textboxTimer = (textboxTimer + 1) mod 40;

if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord("S"))) {
    mint_save_room();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Textbox controls

if (selectedTextbox != noone)
{
    if (keyboard_lastkey != -1)
    {
        var _textbox = selectedTextbox;
        var _update = false;
        var _text = string(selectedTextbox[? "value"]);
        if (keyboard_lastkey == vk_enter)
        {
            script_execute(_textbox[? "finish"], _textbox, _textbox[? "finish arg"]);
            selectedTextbox = noone;
        }
        else if (keyboard_lastkey == vk_backspace)
        {
            if (string_length(_text) &gt; 0)
            {
                _text = string_delete(_text, string_length(_text), 1);
                _update = true;
            }
        }
        else if (keyboard_lastchar != "")
        {
            _text += keyboard_lastchar;
            _update = true;
        }
        
        if (_update)
        {
            if (_textbox[? "numeric"])
            {
                if (string_digits(_text) == _text)
                {
                    _textbox[? "value"] = real(_text);
                    script_execute(_textbox[? "update"], _textbox[? "value"], _textbox[? "update arg"]);
                }
                else
                {
                    _textbox[? "value"] = _text;
                }
            }
            else
            {
                _textbox[? "value"] = _text;
            }
        }
        
        draw_set_font(font);
        var _chars = floor((_textbox[? "width"] - 8) / string_width("a"));
        var _del = max(string_length(_textbox[? "value"]) - _chars, 0);
        _textbox[? "display text"] = string_delete(_textbox[? "value"], 1, _del);
        if (_del &gt; 0)
        {
            _textbox[? "tooltip"] = string(_textbox[? "value"]);
        }
        else
        {
            _textbox[? "tooltip"] = "";
        }
            
        keyboard_lastkey = -1;
        keyboard_lastchar = "";
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update camera

viewX = lerp(viewX, 8 * floor(viewTargetX / 8), viewLerp);
viewY = lerp(viewY, 8 * floor(viewTargetY / 8), viewLerp);
view_xview = floor(viewX - lm / zoom + 0.5);
view_yview = floor(viewY - tm / zoom + 0.5);

zoom = lerp(zoom, targetZoom, viewLerp);

mint_get_scale_handles();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state == "playtest"</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Controls

if (keyboard_check_pressed(bindPlaytest))
{
    mint_get_window_position(true);
    state = "editor";
    room_goto(editorRoom);
}

if (keyboard_check_pressed(bindRestart))
{
    mint_restart_playtest();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Get room, start editor, start playtest

if (state == "init")
{
    mint_get_room();
    mint_get_window_position(true);
    state = "editor";
    room_goto(editorRoom);
}
else if (state == "editor")
{
    window_set_caption("Mint");

    mint_resize_window(true, windowEditorWidth, windowEditorHeight, windowEditorX, windowEditorY);
    room_speed = 60;

    mint_destroy_everything_else();
    
    ds_list_clear(objectPalette);
    
    //Make instances
    for(var i = 0; i &lt; array_height_2d(instances); i++)
    {
        with(instance_create(instances[i, 1], instances[i, 2], objMintInstance))
        {
            object = other.instances[i, 0];
            var sprite = object_get_sprite(object);
            if (sprite == -1)
            {
                sprite = other.defaultSprite;
            }
            sprite_index = sprite;
            image_xscale = other.instances[i, 3];
            image_yscale = other.instances[i, 4];
            image_blend = other.instances[i, 5];
            image_angle = other.instances[i, 6];
            code = other.instances[i, 7];
            
            if (ds_list_find_index(other.objectPalette, object) == -1)
            {
                ds_list_add(other.objectPalette, object);
            }
        }
    }
    
    if (array_length_1d(paletteButtons) == 0)
    {
        ds_list_sort(objectPalette, true);
        
        for(var i = 0; i &lt; ds_list_size(objectPalette); i++)
        {
            mint_add_object_to_palette(objectPalette[| i]);
        }
    }
    
    //Make tiles
    for(var i = 0; i &lt; array_height_2d(tiles); i++)
    {
        with(instance_create(tiles[i, 1], tiles[i, 2], objMintTile))
        {
            back = other.tiles[i, 0];
            left = other.tiles[i, 5];
            top = other.tiles[i, 6];
            width = other.tiles[i, 3];
            height = other.tiles[i, 4];
            image_xscale = other.tiles[i, 9];
            image_yscale = other.tiles[i, 10];
            image_blend = other.tiles[i, 8];
            depth = other.tiles[i, 7];
        }
    }
    
    mint_room_set_backgrounds();
}
else if (state == "start playtest")
{
    mint_on_playtest_start(false);

    for (var i = 0; i &lt; array_height_2d(instances); i++)
    {
        with(instance_create(instances[i, 1], instances[i, 2], instances[i, 0]))
        {
            image_xscale = other.instances[i, 3];
            image_yscale = other.instances[i, 4];
            image_blend = other.instances[i, 5];
            image_angle = other.instances[i, 6];
            var instCode = other.instances[i, 7]; //Do not name this var "code" it will break stuff elsewhere
            for (var j = 0; j &lt; array_height_2d(instCode); j++)
            {
                variable_instance_set(id, instCode[j, 0], instCode[j, 1]);
            }
        }
    }
    
    for (var i = 0; i &lt; array_height_2d(tiles); i++)
    {
        var t = tile_add(tiles[i, 0], tiles[i, 5], tiles[i, 6], tiles[i, 3], tiles[i, 4], tiles[i, 1], tiles[i, 2], tiles[i, 7]);
        tile_set_scale(t, tiles[i, 9], tiles[i, 10]);
        tile_set_blend(t, tiles[i, 8]);
    }
    
    mint_room_set_backgrounds();
    
    mint_resize_window(false, windowPlaytestWidth, windowPlaytestHeight, windowPlaytestX, windowPlaytestY);
    room_speed = roomSpeed;
    
    with(all)
    {
        if (object_index != objMintEditor)
        {
            event_perform(ev_other, ev_room_start);
        }
    }
    
    mint_on_playtest_start(true);
        
    state = "playtest";
}
else if (state == "playtest")
{
    mint_restart_playtest();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state == "editor"</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var xx = view_xview, yy = view_yview;
mint_mouse_update();

if (mode = "instances" &amp;&amp; mouseState = "none" &amp;&amp; !keyboard_check(vk_shift))
{
    var sprite = object_get_sprite(selectedObject);
    if (sprite != -1 &amp;&amp; hoveredInstance == noone)
    {
        draw_sprite_ext(sprite, 0, (instancePreviewX - view_xview) * zoom, (instancePreviewY - view_yview) * zoom, zoom, zoom, 0, c_white, 0.5);
    }
}

if (showGrid)
{
    draw_set_color(c_black);
    draw_set_alpha(0.15);
        if (snapX &gt; 1)
        {
            for(var xx = -view_xview * zoom; xx &lt; (room_width - view_xview) * zoom; xx += snapX * zoom)
            {
                draw_line(xx, -view_yview * zoom, xx, (room_height - view_yview) * zoom);
            }
            draw_line((room_width - view_xview) * zoom, -view_yview * zoom, (room_width - view_xview) * zoom, (room_height - view_yview) * zoom);
        }
        if (snapY &gt; 1)
        {
            for(var yy = -view_yview * zoom; yy &lt; (room_height - view_yview) * zoom; yy += snapY * zoom)
            {
                draw_line(-view_xview * zoom, yy, (room_width - view_xview) * zoom, yy);
            }
            draw_line(-view_xview * zoom, (room_height - view_yview) * zoom, (room_width - view_xview) * zoom, (room_height - view_yview) * zoom);
        }
    draw_set_alpha(1);
}

var alpha = (dsin(current_time / 5) + 1) / 8 + 0.25;
d3d_set_fog(1, c_blue, 0, 0);
for (var i = 0; i &lt; ds_list_size(selectedInstances); i++)
{
    with(selectedInstances[| i])
    {
        draw_sprite_ext(sprite_index, image_index, other.zoom * (x - view_xview), other.zoom * (y - view_yview), other.zoom * image_xscale, other.zoom * image_yscale, image_angle, image_blend, alpha);
    }
}
d3d_set_fog(0, 0, 0, 0);

if (hoveredInstance != noone)
{
    mint_highlight_rectangle(hoveredInstance.bbox_left, hoveredInstance.bbox_top, hoveredInstance.bbox_right, hoveredInstance.bbox_bottom, 0.5, true);
}
if (!ds_list_empty(selectedInstances))
{
    mint_highlight_rectangle(selectionLeft, selectionTop, selectionRight, selectionBottom, 1, true);
    mint_draw_scale_handles();
}
if (mouseState = "selection")
{
    mint_highlight_rectangle(clickStartX, clickStartY, mouse_room_x, mouse_room_y, 1, true);
}

draw_set_color(colorFillDark);
draw_rectangle(0, 0, lm-1, sh-1, false);
draw_rectangle(lm, 0, sw-rm-1, tm-1, false);
draw_rectangle(lm, sh-bm, sw-rm-1, sh-1, false);
draw_rectangle(sw-rm, 0, sw-1, sh-1, false);

var m = 2;
mint_draw_rounded_rectangle(m, m, lm-m-1, tlm-1, 6, colorFillLight);
mint_draw_rounded_rectangle(m, tlm+m, lm-m-1, sh-m-1, 6, colorFillLight);
mint_draw_rounded_rectangle(lm, m, sw-rm-1, tm-m-1, 6, colorFillLight);
mint_draw_rounded_rectangle(lm, sh-bm+m, sw-rm-1, sh-m-1, 6, colorFillLight);
mint_draw_rounded_rectangle(sw-rm+m, m, sw-m-1, sh-m-1, 6, colorFillLight);

mint_draw_gui_elements();

mint_draw_tooltip();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
